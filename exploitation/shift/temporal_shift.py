"""
:author: Philippenko
:date: Juil. 2017

Let c a template and s a segment.
Thus, one wants to write : :math:`c(t) = w1 * s(w3*t + w2) + w0`

This module focuses on the temporal shift characterization that is to say on :math:`w1` and :math:`w2`.

This module is not optimized and could be greatly improved !

.. warning:: Surprisingly the distance computed by the fastdtw package is better for the times series discrimination than our version. 
                Unfortunately, re-compute the distance slow down considerably the recognition process. This have to be fixed !
                
"""
from numpy import array, inf
from utilities.dba import DTWCumulMat, optimal_path, fastdtw, dtw
from sklearn import linear_model
from storage.save import save_double_list
import sys  
from segmentation.segmentation_construction import little_variation
from statistics import median   

from plotting.plot_shift import plot_temporal_shift

def sequence_to_matrix(len_x, len_y, sequence, coordinates):
    """Transforms a sequence in matrix with regards to coordinates. Useful with the path matrix.
    
    Parameters
    ----------
    len_x, len_y: int
        the size of the futur matrix 
    sequence: list 
    coordinates: list of tuple
    
    Returns
    -------
    matrix: numpy.array
    """
    my_matrix=[[max(sequence)*(1+5.0/100)] * (len_x) for _ in range(len_y)]
    for k in range(len(sequence)):
        my_matrix[coordinates[k][1]][coordinates[k][0]]=sequence[k]
        
    return array(my_matrix)
    
def prepare_coordinates_path(opt_path):
    """Transforms the coordinates of the optimal path in a more practical way.
    
    Parameters
    ----------
    opt_path: list
        The optimal path
    (coord_x, coord_y): tuple of list
    """
    opt_path=array(opt_path)
    coord_x=array(opt_path[:,0]).reshape(len(opt_path[:,0]),1)
    coord_y=array(opt_path[:,1])
    return (coord_x, coord_y)

def regression(reg,new_X, new_y, y_level_deb, y_level_fin, len_template):
    # We try to make the regression between the two major trays.
    # The tray are at the position y_level_deb and y_level_fin.
    # That is why we keep only what is between this two level marks.
    new_y_prime=[y for y in new_y if y_level_fin >= y >=y_level_deb] 
    if len(new_y_prime)<3:
        reg.fit(new_X,new_y)
    else:
        new_X=[new_X[i] for i in range(len(new_X)) if new_y[i] in new_y_prime]
        new_y=new_y_prime 
        reg.fit(new_X,new_y)       
    w3=reg.coef_
    # We arbitrarily choose a value of w2.
    if w3==0:
        w2=len_template
    else:
        w2=-reg.intercept_/w3
    return (w2,w3, reg.score, new_X, new_y)

def compute_temporel_shift_parameters(template, serie, plot=False):
    """Computes the temporal shift parameters between a time serie and a template, that is to say w2 and w3.
    
    In that manner:
        1) Compute the cost matrix and search for the best path
        2) Try to found the best linear regression of the path by looking at sub-intervals
        3) w3 is the director coefficients of this straight line
        
    .. warning:: w2 is the number of shift points ! As a result, it an int !
    .. todo:: The selection of the best sub-interval regression is not optimized and very long !
    .. todo:: Dynamic choose of sub-intervals depending of the trays, risings ... and of the the points concentration
    """
    
    len_template=len(template)
    
    template=[template[i] for i in range(0, len(template),2)]
    serie=[serie[i] for i in range(0, len(serie),2)]
    reg = linear_model.LinearRegression()
    reg_select = linear_model.LinearRegression()
    
#     (cost,path,weight)=DTWCumulMat(medoid=template,s=serie)
#     (opt_path,weight_opt_path)=optimal_path(len(template), len(serie),path,weight)
#     dist=cost[-1][-1]
    dist, cost, acc, dump_path, weight_opt_path = dtw(template, serie)  
    opt_path=[]
    for i in range(len(dump_path[0])):
        opt_path.append([dump_path[1][i], dump_path[0][i]])
    
    #########################################################
    # Goal : compute the best linear regression of the path #
    #########################################################    
    
    (X,y)=prepare_coordinates_path(opt_path)
    
    
    ##                                  ##
    ## Intialisation of the regressions ##
    ##                                  ##
    
    # We remove all the peack and all the tray !
    level=len(X)/10 # The peack/tray must have at least level% of the total points
    (new_X,new_y, y_deb, y_fin)=remove_front(X,y,level)
    (new_y,new_X, x_deb, x_fin)=remove_front(new_y,new_X,level)    
    (w2,w3,R_max, new_X, new_y)=regression(reg,new_X, new_y, y_deb, y_fin, len_template)          
    (X_best,y_best)=(new_X,new_y)
    
    ##                                                    ##
    ## Search of the best sub-interval for the regression ##    
    ##                                                    ##
     
    # We decide that there must be at least 20% of the points in the regression model.
    n=len(new_X)
    minus=4*n/10
     
    # Searching of the best sub-intervalle regression. We use a step of three so as to speed up the process.
    for i in reversed(range(1,minus,3)):
        for j in reversed(range(1,minus,2)):
            # We define the new sub-set on which the regression will be performed.
            Xprime=new_X[minus-i:n-minus+j]
            yPrime=new_y[minus-i:n-minus+j]
            reg = linear_model.LinearRegression()
            reg.fit(Xprime,yPrime)
            score=reg.score(Xprime,yPrime)
            if R_max < score:
                reg_best=reg
                R_max=score
                w3=reg.coef_
                if w3==0:
                    w2=-sys.maxint
                else:
                    w2=-reg.intercept_/w3
                X_best=Xprime
                y_best=yPrime                           
 
    (X_select,y_select)=(X_best, y_best)
         
    try:
        reg_select.fit(X_select,y_select)
        score=reg_select.score(X_select,y_select)
        R_max=score
        w3=reg.coef_
        if w3==0:
            w2=len_template
        else:
            w2=-reg.intercept_/w3
    except(ValueError):
        print("Problem when computing the spatial parameters !")
        
    
    if plot:
        print("w2,w3,dist=",w2,w3,dist)
        mat_weight_opt_path=sequence_to_matrix(len(serie), len(template), weight_opt_path, opt_path)
        plot_temporal_shift(template, serie, cost, mat_weight_opt_path,
                            X, y, new_X, new_y, X_best, y_best, y_deb, y_fin)

    # Surprisingly the distance computed by the fastdtw package is better for the times series discrimination than
    # our version.
    from fastdtw import fastdtw as f
    dist=f(serie, template)[0]
#     print("The new dist : ", dist)
    try:
        return (int(w2),w3[0],dist)
    except(ValueError):
        return (len_template,w3[0],dist)

def remove_tray_and_peack(x,y):
    """Remove the trays and the pea
    Examples
    --------
    >>> remove_tray_and_peack([0,1,2,3,4,5,6,7,8,8,8,8,8,8,8,8,8,8],[1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,10])
    ([], [])
    """
    level=len(x)/10
    (X_select,y_select,y_deb, y_fin)=remove_front(x,y,level)
    (y_select, X_select, x_deb, x_fin)=remove_front(y_select,X_select,level)
    return (X_select,y_select, y_deb,y_fin)

def remove_front(x,y,level):
    """
    wsrg
    """
    if len(x)==0 or len(y)==0:
        return (x,y,0,len(y))
    
    x_init=x
    y_init=y
    
    cluster=[[x[i] for i in range(len(x)) if y[i]==j] for j in range(len(y))]
    tray=[]
    new_x=x
    new_y=y
    for k in range(len(cluster)):
        c=cluster[k]
        if len(c)>level:
            tray.append(k)
            new_x=[x[i] for i in range(len(x)) if x[i] not in c]
            new_y=[y[i] for i in range(len(y)) if x[i] not in c]
            x=new_x
            y=new_y
    if tray==[] or len(y)==0:
        return (x_init,y_init,0, len(y_init))
    # Si il n'y a qu'un plateau : est-ce un plateau dans la partie superieur ou dans la partie inferieur.
    elif len(tray)==1:
        if tray[0]>median(y):
            return (new_x,new_y, 0, tray[0])
        return (new_x, new_y, tray[0], len(y))
    else:
        inf=tray[0]
        sup=tray[len(tray)-1]
        # Si les plateau sont tres proches : 
        if little_variation(inf/float(len(y)), sup/float(len(y)), 30):
            if sup>median(y):
                return (new_x,new_y, 0, sup)
            return (new_x,new_y, inf, len(y))
    return (new_x,new_y,tray[0],tray[len(tray)-1])
            



