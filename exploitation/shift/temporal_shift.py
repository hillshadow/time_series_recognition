# # coding: utf-8
# 
# """
# :author: Philippenko
# :date: Juil. 2017
# 
# Let c a template and s a segment.
# Thus, one wants to write : :math:`c(t) = w1 * s(w3*t + w2) + w0`
# 
# This module focuses on the temporal shift characterization that is to say on :math:`w1` and :math:`w2`.
# 
# This module is not optimized and could be greatly improved !
# """
# from numpy import array, inf
# from utilities.dba import DTWCumulMat, optimal_path, fastdtw, dtw
# from sklearn import linear_model
# from storage.save import save_double_list
# import sys  
# from segmentation.segmentation_construction import little_variation
# from statistics import median   
# 
# from plotting.plot_shift import plot_temporal_shift
# 
# def sequence_to_matrix(len_x, len_y, sequence, coordinates):
#     """
#     Transforms a sequence in matrix with regards to coordinates. Useful with the path matrix.
#     
#     Parameters
#     ----------
#     len_x, len_y: int
#         the size of the futur matrix 
#     sequence: list 
#     coordinates: list of tuple
#     
#     Returns
#     -------
#     matrix: numpy.array
#     """
#     my_matrix=[[max(sequence)*(1+5.0/100)] * (len_x+1) for _ in range(len_y+1)]
#     for k in range(len(sequence)):
#         my_matrix[coordinates[k][1]][coordinates[k][0]]=sequence[k]
#         
#     return array(my_matrix)
#     
# def prepare_coordinates_path(opt_path):
#     """
#     Transforms the coordinates of the optimal path in a more practical way.
#     
#     Parameters
#     ----------
#     opt_path: list
#         The optimal path
#     (coord_x, coord_y): tuple of list
#     """
#     opt_path=array(opt_path)
#     coord_x=array(opt_path[:,0]).reshape(len(opt_path[:,0]),1)
#     coord_y=array(opt_path[:,1])
#     return (coord_x, coord_y)
# 
# def regression(reg,new_X, new_y, y_level_deb, y_level_fin, len_template):
#     new_y_prime=[y for y in new_y if y_level_fin >= y >=y_level_deb] 
#     if len(new_y_prime)<2:
#         reg.fit(new_X,new_y)
#     else:
#         new_X=[new_X[i] for i in range(len(new_X)) if new_y[i] in new_y_prime]
#         new_y=new_y_prime 
#         reg.fit(new_X,new_y)       
#     w3=reg.coef_
#     # We arbitrarily choose a value of w2.
#     if w3==0:
#         w2=len_template
#     else:
#         w2=-reg.intercept_/w3
#     return (w2,w3, reg.score, new_X, new_y)
# 
# def compute_temporel_shift_parameters(template, serie, plot=False):
#     """
#     Computes the temporal shift parameters between a time serie and a template, that is to say w2 and w3.
#     In that manner:
#         1) Compute the cost matrix and search for the best path
#         2) Try to found the best linear regression of the path by looking at sub-intervals
#         3) w3 is the director coefficients of this straight line
#         
#     .. warning:: w2 is the number of shift points ! As a result, it an int !
#     .. todo:: The selection of the best sub-interval regression is not optimized and very long !
#     .. todo:: Dynamic choose of sub-intervals depending of the trays, risings ... and of the the points concentration
#     """
#     
#     len_template=len(template)
#     
#     template=[template[i] for i in range(0, len(template),2)]
#     serie=[serie[i] for i in range(0, len(serie),2)]
#     reg = linear_model.LinearRegression()
#     reg_min = linear_model.LinearRegression()
#     reg_select = linear_model.LinearRegression()
#     
# #     (cost,path,weight)=DTWCumulMat(medoid=template,s=serie)
# #     (opt_path,weight_opt_path)=optimal_path(len(template), len(serie),path,weight)
# #     dist=cost[-1][-1]
# 
#     dist, cost, acc, dump_path, weight_opt_path = dtw(template, serie)  
#     opt_path=[]
#     for i in range(len(dump_path[0])):
#         opt_path.append([dump_path[1][i], dump_path[0][i]])
#     
#     #########################################################
#     # Goal : compute the best linear regression of the path #
#     #########################################################    
#     
#     (X,y)=prepare_coordinates_path(opt_path)
#     
#     
#     ##                                  ##
#     ## Intialisation of the regressions ##
#     ##                                  ##
#     
#     # We remove all the peack and all the tray !
#     level=len(X)/10 # The peack/tray must have at least level% of the total points
#     (new_X,new_y, y_deb, y_fin)=remove_front(X,y,level)
#     (new_y,new_X, x_deb, x_fin)=remove_front(new_y,new_X,level)    
#     
#     (w2,w3,R_max, new_X, new_y)=regression(reg,new_X, new_y, y_deb, y_fin, len_template)   
#              
#             
#     (X_min,y_min)=(new_X,new_y)
#     
#     ##                                                    ##
#     ## Search of the best sub-interval for the regression ##    
#     ##                                                    ##
#      
#      #Choose of the sub set
#     n=len(new_X)
#     # TODO : on peux en enlever autant que l'on veut � condition qu'il y ait suffisament de point % au nombre de points r�el
#     minus=4*n/10
#     
#     reg_min=reg
#      
#     # Searching of the best sub-intervalle regression.
#     for i in reversed(range(1,minus,3)):
#         for j in reversed(range(1,minus,2)):
#             Xprime=new_X[minus-i:n-minus+j]
#             yPrime=new_y[minus-i:n-minus+j]
#             reg = linear_model.LinearRegression()
#             reg.fit(Xprime,yPrime)
#             score=reg.score(Xprime,yPrime)
#             if R_max < score:
#                 reg_min=reg
#                 R_max=score
#                 w3=reg.coef_
#                 if w3==0:
#                     w2=-sys.maxint
#                 else:
#                     w2=-reg.intercept_/w3
#                 X_min=Xprime
#                 y_min=yPrime                           
#  
#     (X_select,y_select)=(X_min, y_min)
#          
#     try:
#         reg_select.fit(X_select,y_select)
#         score=reg_select.score(X_select,y_select)
#     except(ValueError):
#         print(X_select,y_select)
#         (X_select,y_select)=(X_min, y_min)
#         reg_select=reg
#         score=0
#          
#     if score>R_max:
#         R_max=score
#         w3=reg.coef_
#         if w3==0:
#             w2=-sys.maxint
#         else:
#             w2=-reg.intercept_/w3
#     X_min=new_X
#     y_min=new_y
#     R_max=1
#         
#     
#     if plot:
#         print("w2,w3,dist=",w2,w3,dist)
#         mat_weight_opt_path=sequence_to_matrix(len(serie), len(template), weight_opt_path, opt_path)
#         plot_temporal_shift(template, serie, cost, mat_weight_opt_path, reg, reg_min, 
#                             X, y, new_X, new_y, X_min, y_min, y_deb, y_fin)
#     # w2 is the number of points shift ! Does not have any sense to return a float !
#    
# #     if w2 < -7:
# #         w2 = w2 % (len(template)*w3)
# #          
# #     if w2 > len(serie)-len(template):
# #         w2 = w2 % (len(serie) - len(template))
#     from fastdtw import fastdtw as f
#     dist=f(serie, template)[0]
#     try:
#         return (int(w2),w3[0],dist)
#     except(ValueError):
#         return (len_template,w3[0],dist)
# 
# def remove_tray_and_peack(x,y):
#     """
#     Examples
#     --------
#     >>> remove_tray_and_peack([0,1,2,3,4,5,6,7,8,8,8,8,8,8,8,8,8,8],[1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,10])
#     ([], [])
#     """
#     save_double_list([int(x[i]) for i in range(len(x))],y,"exemple_qui_foire.csv")
#     level=len(x)/10
#     (X_select,y_select,y_deb, y_fin)=remove_front(x,y,level)
#     (y_select, X_select, x_deb, x_fin)=remove_front(y_select,X_select,level)
#     return (X_select,y_select, y_deb,y_fin)
# 
# def remove_front(x,y,level):
#     if len(x)==0 or len(y)==0:
#         return (x,y,0,len(y))
#     
#     cluster=[[x[i] for i in range(len(x)) if y[i]==j] for j in range(len(y))]
#     tray=[]
#     new_x=x
#     new_y=y
#     for k in range(len(cluster)):
#         c=cluster[k]
#         if len(c)>level:
#             tray.append(k)
#             new_x=[x[i] for i in range(len(x)) if x[i] not in c]
#             new_y=[y[i] for i in range(len(y)) if x[i] not in c]
#             x=new_x
#             y=new_y
#     if tray==[]:
#         return (new_x,new_y,0, len(y))
#     # Si il n'y a qu'un plateau : est-ce un plateau dans la partie supérieur ou dans la partie inférieur.
#     elif len(tray)==1:
#         if tray[0]>median(y):
#             return (new_x,new_y, 0, tray[0])
#         return (new_x, new_y, tray[0], len(y))
#     else:
#         inf=tray[0]
#         sup=tray[len(tray)-1]
#         # Si les plateau sont très proches : 
#         if little_variation(inf/float(len(y)), sup/float(len(y)), 30):
#             if sup>median(y):
#                 return (new_x,new_y, 0, sup)
#             return (new_x,new_y, inf, len(y))
#     return (new_x,new_y,tray[0],tray[len(tray)-1])
            

################################################################
# coding: utf-8

"""
:author: Philippenko
:date: Juil. 2017

Let c a template and s a segment.
Thus, one wants to write : :math:`c(t) = w1 * s(w3*t + w2) + w0`

This module focuses on the temporal shift characterization that is to say on :math:`w1` and :math:`w2`.

This module is not optimized and could be greatly improved !

.. warning:: Surprisingly the distance computed by the fastdtw package is better for the times series discrimination than our version. 
                Unfortunately, re-compute the distance slow down considerably the recognition process. This have to be fixed !
                
"""
from numpy import array, inf
from utilities.dba import DTWCumulMat, optimal_path, fastdtw, dtw
from sklearn import linear_model
from storage.save import save_double_list
import sys  
from segmentation.segmentation_construction import little_variation
from statistics import median   

from plotting.plot_shift import plot_temporal_shift

def sequence_to_matrix(len_x, len_y, sequence, coordinates):
    """Transforms a sequence in matrix with regards to coordinates. Useful with the path matrix.
    
    Parameters
    ----------
    len_x, len_y: int
        the size of the futur matrix 
    sequence: list 
    coordinates: list of tuple
    
    Returns
    -------
    matrix: numpy.array
    """
    my_matrix=[[max(sequence)*(1+5.0/100)] * (len_x) for _ in range(len_y)]
    for k in range(len(sequence)):
        my_matrix[coordinates[k][1]][coordinates[k][0]]=sequence[k]
        
    return array(my_matrix)
    
def prepare_coordinates_path(opt_path):
    """Transforms the coordinates of the optimal path in a more practical way.
    
    Parameters
    ----------
    opt_path: list
        The optimal path
    (coord_x, coord_y): tuple of list
    """
    opt_path=array(opt_path)
    coord_x=array(opt_path[:,0]).reshape(len(opt_path[:,0]),1)
    coord_y=array(opt_path[:,1])
    return (coord_x, coord_y)

def regression(reg,new_X, new_y, y_level_deb, y_level_fin, len_template):
    # We try to make the regression between the two major trays.
    # The tray are at the position y_level_deb and y_level_fin.
    # That is why we keep only what is between this two level marks.
    new_y_prime=[y for y in new_y if y_level_fin >= y >=y_level_deb] 
    if len(new_y_prime)<3:
        reg.fit(new_X,new_y)
    else:
        new_X=[new_X[i] for i in range(len(new_X)) if new_y[i] in new_y_prime]
        new_y=new_y_prime 
        reg.fit(new_X,new_y)       
    w3=reg.coef_
    # We arbitrarily choose a value of w2.
    if w3==0:
        w2=len_template
    else:
        w2=-reg.intercept_/w3
    return (w2,w3, reg.score, new_X, new_y)

def compute_temporel_shift_parameters(template, serie, plot=False):
    """Computes the temporal shift parameters between a time serie and a template, that is to say w2 and w3.
    
    In that manner:
        1) Compute the cost matrix and search for the best path
        2) Try to found the best linear regression of the path by looking at sub-intervals
        3) w3 is the director coefficients of this straight line
        
    .. warning:: w2 is the number of shift points ! As a result, it an int !
    .. todo:: The selection of the best sub-interval regression is not optimized and very long !
    .. todo:: Dynamic choose of sub-intervals depending of the trays, risings ... and of the the points concentration
    """
    
    len_template=len(template)
    
    template=[template[i] for i in range(0, len(template),2)]
    serie=[serie[i] for i in range(0, len(serie),2)]
    reg = linear_model.LinearRegression()
    reg_select = linear_model.LinearRegression()
    
#     (cost,path,weight)=DTWCumulMat(medoid=template,s=serie)
#     (opt_path,weight_opt_path)=optimal_path(len(template), len(serie),path,weight)
#     dist=cost[-1][-1]
    dist, cost, acc, dump_path, weight_opt_path = dtw(template, serie)  
    opt_path=[]
    for i in range(len(dump_path[0])):
        opt_path.append([dump_path[1][i], dump_path[0][i]])
    
    #########################################################
    # Goal : compute the best linear regression of the path #
    #########################################################    
    
    (X,y)=prepare_coordinates_path(opt_path)
    
    
    ##                                  ##
    ## Intialisation of the regressions ##
    ##                                  ##
    
    # We remove all the peack and all the tray !
    level=len(X)/10 # The peack/tray must have at least level% of the total points
    (new_X,new_y, y_deb, y_fin)=remove_front(X,y,level)
    (new_y,new_X, x_deb, x_fin)=remove_front(new_y,new_X,level)    
    (w2,w3,R_max, new_X, new_y)=regression(reg,new_X, new_y, y_deb, y_fin, len_template)          
    (X_best,y_best)=(new_X,new_y)
    
    ##                                                    ##
    ## Search of the best sub-interval for the regression ##    
    ##                                                    ##
     
    # We decide that there must be at least 20% of the points in the regression model.
    n=len(new_X)
    minus=4*n/10
     
    # Searching of the best sub-intervalle regression. We use a step of three so as to speed up the process.
    for i in reversed(range(1,minus,3)):
        for j in reversed(range(1,minus,2)):
            # We define the new sub-set on which the regression will be performed.
            Xprime=new_X[minus-i:n-minus+j]
            yPrime=new_y[minus-i:n-minus+j]
            reg = linear_model.LinearRegression()
            reg.fit(Xprime,yPrime)
            score=reg.score(Xprime,yPrime)
            if R_max < score:
                reg_best=reg
                R_max=score
                w3=reg.coef_
                if w3==0:
                    w2=-sys.maxint
                else:
                    w2=-reg.intercept_/w3
                X_best=Xprime
                y_best=yPrime                           
 
    (X_select,y_select)=(X_best, y_best)
         
    try:
        reg_select.fit(X_select,y_select)
        score=reg_select.score(X_select,y_select)
        R_max=score
        w3=reg.coef_
        if w3==0:
            w2=len_template
        else:
            w2=-reg.intercept_/w3
    except(ValueError):
        print("Problem when computing the spatial parameters !")
        
    
    if plot:
        print("w2,w3,dist=",w2,w3,dist)
        mat_weight_opt_path=sequence_to_matrix(len(serie), len(template), weight_opt_path, opt_path)
        plot_temporal_shift(template, serie, cost, mat_weight_opt_path,
                            X, y, new_X, new_y, X_best, y_best, y_deb, y_fin)

    # Surprisingly the distance computed by the fastdtw package is better for the times series discrimination than
    # our version.
    from fastdtw import fastdtw as f
    dist=f(serie, template)[0]
#     print("The new dist : ", dist)
    try:
        return (int(w2),w3[0],dist)
    except(ValueError):
        return (len_template,w3[0],dist)

def remove_tray_and_peack(x,y):
    """Remove the trays and the pea
    Examples
    --------
    >>> remove_tray_and_peack([0,1,2,3,4,5,6,7,8,8,8,8,8,8,8,8,8,8],[1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,10])
    ([], [])
    """
    level=len(x)/10
    (X_select,y_select,y_deb, y_fin)=remove_front(x,y,level)
    (y_select, X_select, x_deb, x_fin)=remove_front(y_select,X_select,level)
    return (X_select,y_select, y_deb,y_fin)

def remove_front(x,y,level):
    """
    
    """
    if len(x)==0 or len(y)==0:
        return (x,y,0,len(y))
    
    cluster=[[x[i] for i in range(len(x)) if y[i]==j] for j in range(len(y))]
    tray=[]
    new_x=x
    new_y=y
    for k in range(len(cluster)):
        c=cluster[k]
        if len(c)>level:
            tray.append(k)
            new_x=[x[i] for i in range(len(x)) if x[i] not in c]
            new_y=[y[i] for i in range(len(y)) if x[i] not in c]
            x=new_x
            y=new_y
    if tray==[]:
        return (new_x,new_y,0, len(y))
    # Si il n'y a qu'un plateau : est-ce un plateau dans la partie supérieur ou dans la partie inférieur.
    elif len(tray)==1:
        if tray[0]>median(y):
            return (new_x,new_y, 0, tray[0])
        return (new_x, new_y, tray[0], len(y))
    else:
        inf=tray[0]
        sup=tray[len(tray)-1]
        # Si les plateau sont très proches : 
        if little_variation(inf/float(len(y)), sup/float(len(y)), 30):
            if sup>median(y):
                return (new_x,new_y, 0, sup)
            return (new_x,new_y, inf, len(y))
    return (new_x,new_y,tray[0],tray[len(tray)-1])
            



