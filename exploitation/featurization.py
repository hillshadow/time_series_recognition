# coding: utf-8

"""
:author: Philippenko
:date: Juil. 2017

This module implements the featurization process of a time series
"""


from exploitation.shift.spatial_shift import compute_spatial_shift_parameters
from exploitation.shift.temporal_shift import compute_temporel_shift_parameters
from segmentation.segmentation_construction import normalization
from plotting.plot_shift import plot_shifting

import numpy as np
from statistics import stdev



def build_features(segment, templates_library, plot=False):
    """Builds the feature of a time series.
    
    Parameters
    ----------
    segment: list
        The segment to featurized
    templates_library: list of shape (number of template, 2, length of the template)
        The template library. For each class, one has the template time series and the associated dispersion.
    plot: boolean, optional
        default : False
        True if the users want to plot every graph of the featurization.
        Do not recommended, only for debug.
        
    Notes
    -----
    We have tried to smooth the template and the time series before the recognition, looks like it's a bas idea !
    """
    number_of_classe = templates_library.shape[0]
    features = []
    for i in range(number_of_classe):
        template = templates_library[i, 0]
        template_variance = templates_library[i, 1]
        windows_length = int(len(templates_library[0,i]) * (1 + 20.0 / 100))
        normalized_segment = normalization(segment[:windows_length])
        w2, w3, temporal_distance = compute_temporel_shift_parameters(template, normalized_segment, plot)
        shifted_template, shifted_variance, shifted_segment = perform_temporal_shift(template,template_variance,normalized_segment,w2,w3)
        if len(shifted_template)!=len(shifted_segment):
            raise ValueError("The template and the segment have different lengths : "
                             +str(len(shifted_template))+" and "+str(len(shifted_segment))
                             +" respectively.")
        w0, w1, spatial_distance = compute_spatial_shift_parameters(shifted_template, shifted_variance, shifted_segment)
        features.append(w0)
        features.append(w1)
        features.append(spatial_distance)
        features.append(w2)
        features.append(w3)
        features.append(temporal_distance)
        
    # Should we compute the fft and the dispersion on the shifted segment or on the initial one ?
    my_fft = np.fft.fft(segment)
    features.append(np.real(my_fft[0]))
    features.append(np.real(my_fft[1]))
    features.append(np.imag(my_fft[1]))
    features.append(stdev(segment)) 
    
    if plot:
        plot_shifting(segment, normalized_segment, shifted_segment, template)
    return features
        
def perform_temporal_shift(template, template_variance, segment, w2, w3):
    """
    Performs the temporal shift of a time series. 
    
    After this operation the time series and the template must begin at the same moment 
    and have the same speed.
    
    Thus the segment and the template must have the same length.
    
    Parameters
    ----------
    template: list
        the template of the class
    template_variance: list
        the variance of the template.
    segment: list
        the segment to be shifted
    w2: int
        the delay of the time series
    w3: float
        the speed ratio between the template and the time series.
        
    Returns
    -------
    shifted_segment: list
        the temporal shifted segment
    """
    # If the series is in advance or if it is too late, the temporal shift is not performed. 
    # Indeed, one consider that the template should not be recognized in the segment.
    # Thus, one does not try to minimize the spatial distance by shifting and trimming eiher the template or the series.
    # The segment is trimmed so as to get along with the template.
    if w2 < 0 or w2 > len(segment) - len(template): 
        return template,template_variance, segment[0:len(template)]

    else:
        return template, template_variance,match_the_speed(segment[w2:],len(template), w3)
    
def match_the_speed(segment, len_template, w3):
    """
    Match the speed of the current time series w.r.t to the template speed.
    At the end, segment and len_template should must have the same size.
    
    .. warning:: The match as not been implemented ! At the present time only a truncation is carried out
    .. todo:: The matching algorithm have to be designed !
    
    Parameters
    ----------
    segment: list
        The segment to be classified.
    len_template: int
        The length of the template.
    w3: float
        The speed parameter of the segment.
        
    Returns
    -------
    matched_segment: list
        The segment matched to the template and having the same length.
        
    Raises
    ------
    AssertionError: The temporal shift of the segment does not match to the template
        If matched_segment has a length different of the template.
    
    

    """
    matched_segment=segment[:len_template]
    assert len(matched_segment)==len_template, "The temporal shift of the segment does not match to the template"
    return matched_segment
            

# def build_distance_vector(start, serie, plot=False):
#     """
#     Build the distance vector of a sub-serie.
#     
#     At the present time, the sub-serie can not be define. Indeed, the length of the
#     template is needed. 
#     
#     The distance vector is computed regarding all the classes ! And for each activity,
#     there is a new template, with a new length.
#     
#     Parameters
#     -----------
#     serie: list-like
#         the whole serie
#     start:
#         the start point of the considered sub-serie 
#         
#     """
#     distance = []
#     for act in classes[:n_act]:
# #         filename=get_filename(act, "manual")
#         filename = "forecsys_data\\step"
#         template = load_list(filename + "\\average_segment.csv")
#         #template = smoothing(template, 1)  # TODO faut-il vraiment lisser le tempalte ?! Je ne crois pas !
#         template_variance = load_list(filename + "\\dispersion_segment.csv")
#         longueur_fenetre = int(len(template) * (1 + 20.0 / 100))
#         normalized_serie = normalization(serie[start:start + longueur_fenetre])
#         
#         # Calcul de w2,w3
#         (w2, w3, dist) = compute_temporel_shift_parameters(template, normalized_serie, plot)
#         if abs(w2) > len(template) / 2:
#             (w0, w1, dist2) = compute_spatial_shift_parameters(template, template_variance, normalized_serie[:len(template)])
#             half_shifted_serie = normalized_serie[0:len(template)]
#         else:
#             if w2 < 0:
#                 template2 = template[-int(w2):]
#                 template_variance2 = template_variance[-int(w2):]
#                 half_shifted_serie = normalized_serie[0:len(template2)]
#             else:
#                 half_shifted_serie = normalized_serie[int(w2):int(w2) + len(template)]
#                 template2 = template
#                 template_variance2 = template_variance
#             try:
#                 (w0, w1, dist2) = compute_spatial_shift_parameters(template2, template_variance2, half_shifted_serie)
#             except(ZeroDivisionError):
#                 (w0, w1, dist2) = compute_spatial_shift_parameters(template, template_variance, normalized_serie[:len(template)])
#         distance.append(w0)
#         distance.append(w1)
#         distance.append(dist2)
#         distance.append(w2)
#         distance.append(w3)
#         distance.append(dist)
#     my_fft = np.fft.fft(half_shifted_serie)
#     distance.append(np.real(my_fft[0]))
#     distance.append(np.real(my_fft[1]))
#     distance.append(np.imag(my_fft[1]))
#     distance.append(stdev(serie[start:start + longueur_fenetre])) 
#         
#     if plot:
#         plot_shifting(serie[start:start + longueur_fenetre], normalized_serie, half_shifted_serie, template)
# 
#     return distance



