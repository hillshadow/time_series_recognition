# coding: utf-8

# coding: utf-8
'''
:author: Philippenko
:date: Juil. 2017

This is the main module of the exploitation package.
It carries out the recognition of a time series.
'''

import numpy as np

from plotting.plotting import plot_recognition
import storage.load as ld
from exploitation.featurization import build_features   
    
def continuous_recognition(serie, deb=0, fin=None, files_node="time_series_recognition\\forecsys_data",
                           classes=["step", "other_classe"], mono_class=None, clf=None, index=None,
                           plot=False, save=True):
    """Carries out the continuous recognition of a time series. 
    
    Parameters
    ----------
    serie: list
        The series to be recognized
    deb: int, optional
        default : 0
        The start point of the recognition
    fin: int, optional
        default : None.
        The end point of the recognition, if None the the recognition is performs until the end.
    files_node: string, optional
        default : forecys_data
        The node of the files, that is to say the path to the file where all the recognition
        information are saved.
    classes : list of classe, optional
        default : ["step", "other_classe"]
        The classes which could be recognized by the classifier.
    mono_class: string, optional
        default : None
        If the recognized series is consituted by a single class, you can precise it so as to maker
        the title of the plotted graph more precise.
    clf: classifier, optional
        default : None
        The *fitted* classifier to use. If none the default classifier is used that is to say, the
        one which is save at the root.
        .. warning:: the classifier must be already fitted
    index: list of int, optional
        default : None
        The index of the features to consider for the classification
    plot: boolean, optional
        default : False
        Set to true if you want to plot each graph of the recognition.
        .. warning:: Not recommended. Only for debug.
    save: boolean, optional
        default : True
        Set to False if you do not want that the graph be saved. Instead it will be displayed at the screen.
        
    Returns
    -------
    recognized: a list of shape (number of classes, number of recognized segment, 2)
        [start_point, end_point] : where the class have been recognized
        
    Notes
    -----
    The default parameters match to the default organization of the files.
    """
    print("Recognition")
    if fin is None:
        fin=len(serie)
    if clf is None:
        clf=ld.load(files_node+"\\fitted_classifier.txt")
        
    templates_library=ld.load(files_node+"\\templates_library.txt")
    len_max_template=max([len(t) for t in templates_library[:,0]])
    windows_length = int(len_max_template * (1 + 20.0 / 100))
    t_current=len_max_template*(1+20/100)+deb
    
    # If there is a template less than the number of classe that means that there is a dump classe
    # which gather all the other and undefined classe. Thus, without template.
    other_classe=(templates_library.shape[0]==len(classes)-1)
    if other_classe:
        marker=[[] for c in classes[:-1]]
        marker_fin=[[] for c in classes[:-1]]
    else:
        marker=[[] for c in classes]
        marker_fin=[[] for c in classes]
    t0=deb
    
    while(t_current < fin):
        vector=build_features(serie[t0:t0+windows_length], templates_library, plot)
        if index is not None:
            vector_prime=[vector[i] for i in index]
        else:
            vector_prime=vector
        predicted_classe=clf.predict([vector_prime])
        if (predicted_classe==len(classes)-1 and other_classe):
            t0+=1
            t_current+=1
        else:
#             build_features(serie[t0:t0+windows_length], templates_library, plot)
            len_template=templates_library[predicted_classe,0,:].shape[1]
            marker[predicted_classe[0]].append(t0+vector[3])
            if vector[4]==0:
                t_fin=max(vector[3]+len_template,len_template)
                t0=t0+t_fin
                t_current=t_current+t_fin
            else:
                t_fin=max(vector[3]+int(len_template/vector[4]),int(len_template/vector[4]))
                t0=t0+int(len_template/vector[4])+vector[3]
                t_current=t_current+int(len_template/vector[4])+vector[3]
            marker_fin[predicted_classe[0]].append(t0)
    for i in range(len(marker)):
        plot_recognition(serie, np.array(marker[i]), np.array(marker_fin[i]), classes[i], str(clf)[0:9],save, mono_class)
    return np.array([[[marker[j][i],marker_fin[j][i]] for i in range(len((marker[j])))] for j in range(len(marker))])
  
